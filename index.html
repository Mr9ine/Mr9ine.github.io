<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Xu">


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Mr9ine">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mr9ine">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr9ine">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Mr9ine" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Mr9ine</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/logo.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Xu</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Xu</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/logo.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Xu</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-论文报告0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/10/论文报告0/" class="article-date">
      <time datetime="2019-07-10T10:23:53.000Z" itemprop="datePublished">2019-07-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/论文报告0/">论文报告</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>随着无线局域网的广泛使用，有很多攻击者伪造一些rogue APs，造成敏感信息的泄露，加上rogue AP容易布置，所以更加增加了对无线使用者的威胁。三篇论文都围绕此主题从不同的角度方法进行检测（detect）</p>
<h2 id="一、A-client-side-detection-mechanism-for-evil-twin"><a href="#一、A-client-side-detection-mechanism-for-evil-twin" class="headerlink" title="一、A client-side detection mechanism for evil twin"></a>一、A client-side detection mechanism for evil twin</h2><ol>
<li>随着无线局域网的广泛使用本篇论文主要讨论解决检测evil twin的问题。文中提出有两种解决方向，一种是基于管理权限的，一种是基于用户角度的。本文主要是讨论用户角度。</li>
<li>原理：在Windows或者绝大多数操作系统中，可以运行monitor 模式，这个模式好处在于可以不需要连接任何AP就可以检测出无限流量。因为evil twin需要连接合法的AP连接网络，所以evil twin需要两种无限适配器，一个用来吸引用户，一个用来连接合法的AP，所以传输包是一个evil twin攻击的最基本的现象，ET detector就是基础此性质。<br>ET detector 被动的观察检测AP是否传输了无限包。</li>
<li>过程：首先初始化系统，浏览出SSID BSSID加密类型等信息，在排除相同的SSID的AP后，选择具有相同SSID的AP进行检测。然后通过检测节点捕获包，ET detector利用结果数字与确认数字计算哈希索引，利用攻击者不会改变结果数字与确认数字的属性，检测是否其他哈希桶内也有相同的哈希索引。如果在局域网内，只有一个用户，可以使用类似于手机的设备进行。</li>
<li>缺点与未来工作：缺点就是攻击者使用类3G/4G网络等不同渠道传输包，则ET detector不能检测到这类rogueAP。而且这个方法基于可以运行monitor模式的系统，未来需要在不同SSID的情况下进行功能扩展。<h2 id="二、CETAD：Detecting-Evil-Twin-Access-Point-Attacks-in-Wireless-Hotspots"><a href="#二、CETAD：Detecting-Evil-Twin-Access-Point-Attacks-in-Wireless-Hotspots" class="headerlink" title="二、CETAD：Detecting Evil Twin Access Point Attacks in Wireless Hotspots"></a>二、CETAD：Detecting Evil Twin Access Point Attacks in Wireless Hotspots</h2></li>
<li>为了应对evil twin的攻击，本文在用户角度提出了CETAD，仅仅利用APP就可利用公共服务器检测出evil twin AP。</li>
<li>原理：当多AP布置在热点内时，往往通过相同的ISP连接到互联网。因此除了相同的SSID还有相似的网络参数（ISP name、Global IP Address、RTT）。本文的检测原理就是在legitimate与evil AP之间的类似的ISP不同的RTT值和RTT的标准差等信息进行区别。<br>本文划分了多种Hotspot类型，有单AP、多AP的情况。其中多AP拥有相同的SSID。而且还区分了多种Evil Twin 攻击类型，包括通过攻击者使用移动网络、使用被攻击者相同的AP。在无攻击的时候，legitimate和evil AP有相同的ISP IP address和相似的RTT；在Mobi攻击时候，二者的IP address ISP不同 RTT值也可能不同；在Multihop攻击的时候，RTT不同。利用这些差异进行legitimate AP与Evil Twin的区分。</li>
<li>过程：总体分为安全数据收集阶段与检测阶段。首先浏览无限热点检测需要的SSID的可用AP（设置一个较低的信号临界值，大于信号临界值的AP收集信息），连接一个AP然后收集DHCP信息，通过连接公共服务器收集ISP信息，通过创建HTTPS连接收集RTT信息。在检测阶段首先查看ISP信息是否相同来区别Mobi攻击，然后利用基于时间的RTT值来检测Multiple攻击。</li>
<li>优点：只需要用安装APP的形式，不需要提前训练与安装任何附加的硬件即可实现探测。而且在不同的角度进行探测可以增加探测成功的概率。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络14" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/06/计算机网络14/" class="article-date">
      <time datetime="2019-07-06T07:28:49.000Z" itemprop="datePublished">2019-07-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/06/计算机网络14/">计算机网络（十四）：（接）应用层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用C/S模型</li>
<li>根域名服务器：用来管辖顶级域，通常它并不直接把待查询的域名直接转换成IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询</li>
<li>顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名</li>
<li>授权域名服务器（权限域名服务器）：每一个主机都必须在授权域名服务器处登记。为了更加可靠地工作，一个主机最好至少有两个授权域名服务器。实际上，许多域名服务器都同时充当本地域名服务器和授权域名服务器。授权域名服务器总是能够将其管辖的主机名转换为该主机的IP地址</li>
<li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。</li>
<li>域名解析是指把域名映射成IP地址或把IP地址映射称为域名的过程。前者称为正向解析，后者称为反向解析</li>
<li>域名解析的两种方式：递归查询和递归与迭代相结合的查询</li>
<li>递归与迭代相结合方式：<br>主机向本地域名服务器的查询采用的是递归查询。即如果本地主机所询问的本地服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询<br>本地域名服务器向根域名服务器的查询采用迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器，“你下一步应该想哪一个顶级域名服务器进行查询”  </li>
<li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个DNS服务器接收到DNS结果时，它能将该DNS信息缓存在高速缓存中。</li>
<li>主机名和IP地址之间的映射不是永久的，所以DNS服务器在一段时间后丢弃高速缓存中的信息<br>主机、域名、IP之间并不具有一 一对应的关系</li>
<li>FTP采用C/S的工作方式，使用TCP可靠地传输服务。</li>
<li>FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干个从属进程，负责处理单个请求</li>
<li>FTP在工作时使用两个并行的TCP连接，一个是控制连接（端口号21），一个是数据连接（端口号20）。使用两个不同的端口号可使协议更加简单和更容易实现</li>
<li>控制连接用来传输控制信息（如连接请求，传送请求等）。在传输文件时还可以使用控制连接（例如，客户在传输中途发一个终止传输的命令），因此控制连接在整个会话期间一直保持打开状态<br>数据连接在文件传输完毕后关闭</li>
<li>一个电子邮件系统的三个最主要的组成构件：用户代理、邮件服务器和电子邮件使用的协议，如SMTP、POP3（或IMAP）。注意：三段TCP连接</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络13" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/01/计算机网络13/" class="article-date">
      <time datetime="2019-07-01T02:29:53.000Z" itemprop="datePublished">2019-07-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/计算机网络13/">计算机网络（十三）：应用层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>在C/S模型中，服务器总是处于打开状态（除非某人把它关了）</li>
<li>常见的使用C/S模型的应用包括Web、文件传输（FTP）、远程登录和电子邮件等 </li>
<li>C/S模型的主要特点：<br>网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的<br>客户机相互之间不能通信<br>可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限  </li>
<li>P2P模型：整个网络中的传输内容不再被保存在中心服务器上，每个节点都同时具有下载、上传的功能，其权利和义务都是大体对等的</li>
<li>在P2P模型中，各计算机没有固定的客户机和服务器的划分。任意一对计算机称为对等方，直接相互通信。</li>
<li>实际上，P2P本质上仍然是使用C/S模式，每个节点既作为客户机去访问其他节点的资源，也作为服务器去提供资源给其他节点访问。  </li>
<li>与C/S模型相比，P2P模型的优点主要体现在：<br>减轻了服务器的计算压力<br>多个客户机之间可直接共享文档<br>可扩展性好<br>网络健壮性强  </li>
<li>P2P模型的缺点：在获取服务的同时，还要给其他节点提供服务，因此会占用较多的内存，影响整机运行速度</li>
<li>DNS系统采用C/S模型，其协议运行在UDP之上，使用53号端口</li>
<li>级别最低的域名写在最左边，级别最高的顶级域名写在最右边。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络12" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/25/计算机网络12/" class="article-date">
      <time datetime="2019-06-25T06:30:53.000Z" itemprop="datePublished">2019-06-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/25/计算机网络12/">计算机网络（十二）：（接）传输层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>发送方的发送窗口的大小=MIN｛rwnd，cwnd｝<br>拥塞控制：防止过多的数据注入网络，这样可以使网络中的路由器或链路不致过载</li>
<li>拥塞控制和流量控制的区别：拥塞控制是让网络能够承受现有的网络负荷，它是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收</li>
<li>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映了网络的当前容量</li>
<li>慢开始算法：在TCP刚刚连接好，开始发送TCP报文段时，先令拥塞窗口cwnd=1，即一个最大报文段长度MSS。而在每收到一个对新的报文段的确认后，将cwnd加1，即增大一个MSS（所以经过一个RTT后，cwnd应该是变为原来的2倍）。当把拥塞窗口增大到一个规定的慢开始门限ssthresh（阈值），然后改用拥塞避免算法</li>
<li>拥塞避免算法：发送端的拥塞窗口cwnd每经过一个RRT就增加一个MSS的大小，而不是加倍（经过一个RRT和收到对一个报文段的确认是完全不同的）。当出现一次超时时，则令慢开始门限ssthresh等于当前cwnd的一半（乘法减小）</li>
<li>当网络出现拥塞时，无论在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生（没有按时收到确认，重传计时器超时），就要把慢开始门限ssthresh设置为出现拥塞时的发送方cwnd的一半（但不能小于2），然后把拥塞窗口的cwnd重新设置为1，执行慢开始算法</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络11" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/20/计算机网络11/" class="article-date">
      <time datetime="2019-06-20T08:30:50.000Z" itemprop="datePublished">2019-06-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/20/计算机网络11/">计算机网络（十一）：（接）传输层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>##TCP报文首部一些字段的意义：</p>
<ol>
<li>序号字段。占4字节，TCP连接中传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号字段。占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。与数据链路层的ACK不同</li>
<li>数据偏移。占4位，即首部长度，单位是4字节。与IP数据报分片的数据偏移不同</li>
<li>紧急位URG。当URG=1时，表明紧急指针字段有效。数据从第一个字节到紧急指针所指字节就是紧急数据</li>
<li>确认位ACK。只有当ACK=1时确认号字段才有效，当ACK=0时，确认号无效。TCP规定，在连接建立后，所有传送的报文段都必须把ACK置为1</li>
<li>推送位PSH。接收TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li>
<li>复位位RST。当RST=1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接</li>
<li>同部位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN=1,ACK=0时，表明这是一个连接请求报文；当SYN=1,ACK=1时，表示这是一个连接接收报文</li>
<li>终止位FIN。FIN=1表示此报文段的发送方的数据已发送完毕，并要求释放连接</li>
<li>窗口字段。占2字节，指出了现在运行对方发送的数据量，可动态变化。与数据链路层的窗口还是有很大不同的</li>
<li>检验和。占2字节，检验范围包括首部和数据。检验方法同UDP检验和，只需把伪首部的第四个协议字段改为6即可。UDP协议字段是17</li>
<li>紧急指针字段。占16位，指出本报文段中紧急数据共有多少个字节</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/18/计算机网络10/" class="article-date">
      <time datetime="2019-06-18T03:00:00.000Z" itemprop="datePublished">2019-06-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/计算机网络10/">计算机与网络（十）：传输层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>传输层属于面向通信的最高层，同时也是用户功能中的最低层</li>
<li>传输层提供应用进程之间的逻辑通信（即端到端的通信），与网络层的区别是，网络层提供的是主机之间的逻辑通信</li>
<li>传输层的复用和分用：复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据；分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</li>
<li>传输层还要对收到的报文进行差错检测（首部和数据部分），而网络层只检查IP数据报的首部（首部校验和），不检验数据不符是否会出错</li>
<li>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路，要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）</li>
<li>服务访问点（SAP）：数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口<br>服务端使用的端口号：分两种。一类为熟知端口号，数值为0~1023，这些端口号被指定给了TCP/IP最重要的一些应用程序；另一类叫做登记端口号，数值为1024~49151，它是为没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记</li>
<li>应用程序|FTP|TELNET|SMTP|DNS|TFTP|HTTP|SNMP<br>–|–|–|–|–|–|–|–:<br>熟知端口号|21|23|25|53|69|80|161</li>
<li>客户端使用的端口号：数值为49152~65535.这类端口仅在客户进程运行时才动态选择，因此又叫短暂端口，又称临时端口</li>
<li>套接字 = （主机IP地址，端口号）<br>使用TCP的典型协议有FTP、HTTP、TELNET等；使用UDP的协议主要有TFTP（小文件传输协议）、DNS、实时协议（RTP）</li>
<li>UDP在IP之上仅提供两个附加服务：复用和分用以及差错检测</li>
<li>UDP较TCP的优点：<br>无需建立连接，没有建立连接的时延<br>无连接状态。一些专用应用服务器使用UDP时，可以支持更多的活动客户机<br>分组首部开销小。TCP首部20字节，UDP首部仅8字节<br>应用层能更好地控制要发送的数据和发送时间。UDP没有拥塞控制，因此网络中的拥塞也不会影响主机的发送效率。对于某些实时性应用，允许一些数据的丢失，但是不允许有较大的时延  </li>
<li>校验和：检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和，则直接令该字段为全0</li>
<li>在计算校验和时，要在UDP数据报之前增加12个字节的伪首部。伪首部既不向下传送也不向上递交，仅仅只是为了计算校验和。既检查UDP数据报，也对IP数据报的源IP地址和目的IP地址进行了校验。</li>
<li>对于计算UDP校验和注意：是使用16位二进制码直接进行二进制加法，有进位则加到下一位；若最高位有进位则加到最后一位，循环，直到无进位产生最后取反。比如：111 + 111 = 111。首先，1 + 1 = 0（进位1），然后 1 + 1 + 1（进位） = 1 （再进位1），再1 + 1 + 1（进位） = 1（再进位1，此时进位1加到最后一位），最后一位得到最高位的进位，变为1，不产生进位。因此最后结果为111</li>
<li>每一条TCP只能是点对点的，TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存</li>
<li>TCP是面向字节流的 TCP传送的数据单元称为报文段</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络9" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/14/计算机网络9/" class="article-date">
      <time datetime="2019-06-14T14:57:28.110Z" itemprop="datePublished">2019-06-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/计算机网络9/">计算机与网络（九）：（接）网络层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>主机号全为0，表示本网络本身</li>
<li>主机号全为1，表示本网络的广播地址</li>
<li>网络号为127为环回测试地址。127.0.0.0网络保留作为环路自检地址，此地址表示任意主机本身，目的地址为环回地址的IP数据报永远不会出现在任何网络上</li>
<li>32位全为0，即0.0.0.0，表示本网络上的本主机<br>32位全为1，即255.255.255.255，表示整个TCP/IP网络的广播地址，又称受限广播地址。实际使用时，由于路由器对广播域的隔离，255.255.255.255等效为本网络的广播地址</li>
<li>128.0和192.0.0这两个网络号不可指派<br>私有IP地址只用于LAN，不用于WAN连接；私有IP地址被LAN重复使用</li>
<li>A类私有地址：1个A类网段，即10.0.0.0 ~ 10.255.255.255<br>B类私有地址：16个B类网段，即172.16.0.0 ~ 172.31.255.255<br>C类私有地址：256个网段，192.168.0.0 ~ 192.168.255.255  </li>
<li>NAT转换表中存放着｛本地IP地址：端口｝到｛全球IP地址：端口｝的映射</li>
<li>普通路由器在转发IP数据报时，不改变其源IP地址和目的地址。而NAT路由器在转发IP数据报时，一定要更换其IP地址（转换源IP地址或目的IP地址）。<br>普通路由器仅工作在网络层，而NAT路由器转发数据报时需要查看和转换传输层的端口号</li>
<li>子网划分：从主机号借用若干个比特作为子网号，原网络号不变。三级IP地址 = ｛&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;｝</li>
<li>无论是IPV4还是CIDR（无分类域间路由选择），都不能指派主机号为全0或全1的IP地址给主机<br>IP地址的子网掩码其实就是告诉你这个IP地址的前多少位是网络号+子网号  </li>
<li>CIDR：IP = ｛&lt;网络前缀&gt;，&lt;主机号&gt;｝，消除了传统A,B,C类网络划分<br>CIDR斜线记法：IP地址/网络前缀所占比特数<br>CIDR地址块仍可以再划分子网  </li>
<li>将网络前缀都相同的连续的IP地址组成“CIDR”地址块。一个CIDR地址块可以表示很多地址，这种地址的聚合称为路由聚合，或称为构成超网</li>
<li>最长前缀匹配（最佳匹配）：在查找路由表时，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因而路由就越具体</li>
<li>通常用二叉线索存储CIDR路由表  </li>
<li>IP数据报再被路由器转发时其数据链路层封装所使用的MAC地址是不断改变的</li>
<li>ARP协议：地址解析协议。完成IP地址到MAC地址的映射</li>
<li>每个主机都设有一个ARP高速缓存，存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表</li>
<li>ARP工作在网络层，工作原理……<br>ARP请求分组是广播发送，但是ARP响应分组是单播传送</li>
<li>DHCP协议：动态主机配置协议。DHCP协议是应用层协议，它是基于UDP的。</li>
<li>DHCP协议工作原理：它使用客户/服务器方式。需要IP地址的主机在启动时向DHCP服务器广播发送发现报文，这时该主机称为DHCP客户。本网络上的所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫提供报文</li>
<li>DHCP具体工作过程：DHCP发现—》DHCP提供—-》DHCP请求—-》DHCP确认</li>
<li>DHCP协议的客户端和服务端需要通过广播方式来进行交互，原因是DHCP协议执行期间，客户端和服务端都没有标明自己身份的IP地址，因此不可能通过单播形式进行交互。在传输层采用UDP同理分析</li>
<li>ICMP：网际控制报文协议。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。</li>
<li>ICMP协议是IP层协议。ICMP报文种类有两种，即ICMP差错报告报文和ICMP询问报文</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络8" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/10/计算机网络8/" class="article-date">
      <time datetime="2019-06-10T14:26:26.440Z" itemprop="datePublished">2019-06-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/10/计算机网络8/">计算机网络（八）：网络层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>网络层的功能：<br>异构网络互联<br>路由与转发。路由表的两大功能：路由选择和分组转发<br>拥塞控制  </li>
<li>判断网络是否进入拥塞状态的方法是观察网络的吞吐量与网络的负载的关系：如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就可能进入了“轻度拥塞状态”；如果网络的吞吐量随着网络负载的增大反而下降，网络就可能进入拥塞状态；如果网络的负载继续增大，而网络的吞吐量下降到0，网络就可能进入了死锁状态</li>
<li>拥塞控制的方法：<br>开环控制。在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。它是一种静态的预防方法，在做决定时不考虑当前网络的状态<br>闭环控制。采用监测网络系统，基于反馈环路，它是一种动态的方法</li>
<li>静态路由算法（非自适应路由算法）：由网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。</li>
<li>动态路由算法（自适应路由算法）：指路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，而这些路由信息是在一定时间间隙里不断更新，以适应不断变化的网络，以随时获得最优的寻路效果</li>
<li>常用动态路由算法可分为两类：距离-向量路由算法（典例为RIP算法）和链路状态路由算法（典例为OSPF算法）<br>距离向量路由算法：所有的节点都定期地将它们的整个路由选择表传送给所有与之直接相邻的节点。路由选择表中包含：1.每条路径的目的地（另一节点） 2.路径的代价（也称距离）。</li>
<li>距离向量算法中，所有节点都监听其他相邻节点传送来的路由选择更新信息，并在下列情况下更新它们的路由选择表：<br>被通告一条新的路由，该路由在本节点的路由表中不存在，此时本地系统加入这条新的路由<br>发送来的路由信息中有一条到达某个目的地的路由，该路由比当前使用的路由有较短的距离（较小的代价）。此种情况下，就用新路由替换路由表中达到目的地的那个现有路</li>
<li>RIP算法采用“跳数”作为距离的度量。跳数指从源IP到目的IP所经过的路由个数，经过一个路由器跳数加1</li>
<li>链路状态路由算法：要求每个参与该算法的节点都有完全的网络拓扑信息。首先，主动测试所有邻接节点的状态；然后，定期地将链路状态传播给所有其他的节点。使用Dijsktra最短路径算法计算路由</li>
<li>链路状态路由算法三点特征：向本自治系统中所有路由器发送消息，使用的方式为洪泛法，即路由器通过所有端口向所有相邻的路由器发送信息，而每一个相邻路由器又将此信息发往其所有相邻路由器（但不再发给刚刚发来消息的那个路由器）<br>发送的信息是与该路由器相邻的所有路由器的链路状态，所谓“链路状态”，就是指本路由器都和哪些路由器相邻以及该链路的“度量”。对于OSPF算法，链路状态的“度量”主要用来表示费用、距离、时延、带宽等<br>只有当链路状态发生变化时，路由器才向所有路由器发送此消息  </li>
<li>距离-向量路由算法与链路状态路由算法的比较：在距离-向量路由算法中，每个节点仅与它的直接邻居交谈，它为它的邻居提供了从自己到网络中所有其他节点的最低费用估计。在链路状态路由算法中，每个节点通过洪泛法的方式与其他所有节点交谈，但它仅告诉它们与它直接相连的链路的费用</li>
<li>距离-向量路由算法可能遇到路由环路等问题。<br>因特网将整个互联网划分为许多较小的自治系统，一个自治系统里面包含很多局域网，每个自治系统有权自主地决定本系统内应采用何种路由选择协议</li>
<li>一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称为域内路由选择，具体的协议有RIP和OSPF</li>
<li>自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也称为域间路由选择，具体的协议有BGP</li>
<li>当使用层次路由时，OSPF将一个自治系统再划分为若干个区域，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络7" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/09/计算机网络7/" class="article-date">
      <time datetime="2019-06-09T14:07:33.740Z" itemprop="datePublished">2019-06-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/计算机网络7/">计算机网络（七）：（接）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li>CSMA/CD协议适用于有线局域网</li>
<li>CSMA/CA协议：CA = Collision Avoidance，碰撞避免，广泛应用于无线局域网。碰撞避免并不是指协议可以完全避免碰撞，而是指协议的设计要尽量减少碰撞发生的概率</li>
<li>CSMA/CA还使用预约信道、ACK帧、RTS/CTS帧三种机制来实现碰撞避免<br>CSMA/CA预约信道：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间内不发送数据，从而避免碰撞<br>CSMA/CA ACK帧</li>
<li>CSMA/CA RTS/CTS帧：可选的碰撞避免机制，主要用于解决无线网中“隐蔽站”的问题</li>
<li>CSMA/CD通过电缆中电压的变化来检测，而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式</li>
<li>轮询访问介质访问控制：典型为令牌传递协议，主要用在令牌环局域网。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并由该始发站撤销该帧。帧的目的站除转发帧外，应针对该帧维持一个副本，并通过在帧的尾部设置“响应比特”来指示已收到此副本</li>
<li>只有拿到令牌才能发送数据帧，而令牌只有一个，因此令牌传递协议不会发生冲突；一次只能发送一帧</li>
<li>局域网的特性主要由三个要素决定：拓扑结构、传输介质和介质访问控制方式，其中最重要的为介质访问控制方式</li>
<li>常见的局域网拓扑结构：星形结构、环形结构、总线形结构和环形和总线形结合的复合型结构</li>
<li>局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质</li>
<li>局域网的介质访问控制方式主要有：CSMA/CD、令牌总线和令牌环。其中前两种方法主要用于总线型局域网，令牌环主要用于环形局域网</li>
<li>以太网（IEEE802.3，目前使用范围最广的局域网）—–逻辑拓扑是总线型结构，物理拓扑是星形或拓展星形结构。</li>
<li>令牌环（IEEE802.5）:逻辑拓扑是环形结构，物理拓扑是星形结构<br>FDDI（IEEE802.8，光纤分布数字接口）:逻辑拓扑是环形结构，物理拓扑是星形结构<br>IEEE802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，并将数据链路层拆分为两个子层：逻辑链路控制LLC子层和媒体接入控制MAC子层。</li>
<li>以太网MAC帧格式两种标准：DIX Etheernet V2标准和IEEE 802.3标准</li>
<li>高速以太网：速率达到或超过100Mb/s的以太网<br>100BASE-T以太网：使用CSMA/CD协议，既支持全双工又支持半双工方式；在全双工方式下不使用CSMA/CD协议<br>吉比特以太网：允许在1Gb/s下用全双工和半双工两种方式工作。<br>吉比特以太网：使用光纤作为传输媒体。只工作在全双工方式，没有争用问题。  </li>
<li>在无线局域网（802.11）中，即使在发送过程中发生了碰撞，也要把整个帧发送完毕。而在有线局域网中，发送冲突则节点立即停止发送数据  </li>
<li>802.11标准规定无线局域网最小构件是基本服务集（BSS）。一个基本服务集包括一个基站（接入点，AP）和若干个移动站</li>
<li>交换机在单个网络中转发分组，路由器在多个网络构成的互联网中转发分组</li>
<li>局域网使用的协议主要在数据链路层（还有少量在物理层），而广域网使用的协议主要在网络层 </li>
<li>广域网数据链路层控制协议：PPP协议和HDLC协议<br>PPP协议：串行线路，面向字节。由三个部分组成：链路控制协议LCP、网络控制协议NCP以及一个将IP数据报封装到串行链路的方法。<br>PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验）。它是不可靠的传输协议，不使用序号和确认机制<br>PPP只支持点对点的链路通信，不支持多点线路；PPP只支持全双工链路  PPP的两端可以运行不同的网络层协议，但仍然可以使用同一个PPP进行通信<br>HDLC协议：面向比特；全双工通信；所有帧采用CRC校验，对信息帧进行顺序编号<br>HDLC用于链路的两种基本配置：非平衡配置和平衡配置<br>HDLC站的类型：主站、从站和复合站<br>HDLC数据操作方式：正常响应方式、异步平衡方式和异步响应方式<br>HDLC三类帧：信息帧、监督帧和无编号帧  </li>
<li>两个或多个以太网通过网桥连接起来后，原来的每个以太网称为一个网段。  </li>
<li>网络1和网络2通过网桥连接后，网桥接收网络1发送的数据帧，检查数据帧中的地址，如果是网络2的地址，就转发给网络2；如果是网络1的地址，就将其丢弃。因为源站和目的站处于同一个网段，目的站能够直接收到这个帧而不需要借助网桥的转发</li>
<li>一般情况下，存储转发类设备都可以进行协议转换，即连接的两个网段可以使用不同的协议  </li>
<li>网桥只适合于用户数不多和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞，这就是所谓的广播风暴<br>透明网桥（选择的不是最佳路由）：它接收与之相连的所有LAN传送的每一帧，到达帧的路由选择过程取决于源LAN和目的LAN。<br><strong>源LAN和目的LAN相同，则丢弃该帧,源LAN和目的LAN不同，则转发该帧, 目的LAN未知，则扩散该帧</strong></li>
<li>透明网桥采用自学习算法处理收到的帧并构造转发表；透明网桥使用了一种生成树算法（无环），以确保每个源到每个目的地只有唯一的路径<br>源路由网桥（选择的是最佳路由）：路由选择由发送数据帧的源站负责。为了找到最佳路由，源站以广播的方式向目的站发送一个发现帧作为探测用。<br>网桥的端口一般连接局域网，而交换机的端口一般直接与局域网中的主机相连</li>
<li>以太网交换机就是一个多端口的网桥。利用以太网交换机还可以很方便地实现虚拟局域网（VLAN），VLAN不仅可以隔离冲突域，也可以隔离广播域<br>以太网交换机一般具有多种速率的端口<br>以太网交换机主要采用两种交换模式，即直通式和存储转发式<br>直通式交换机：只检查帧的目的地址。速度很快，但无法支持不同速率的端口的交换  </li>
<li>存储转发式交换机：先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，将其丢弃。支持不同速度端口间的转换<br>第三章所学就是一个上层boss的秘书，帮忙传送一些文件并给以标号。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/05/计算机网络6/" class="article-date">
      <time datetime="2019-06-05T14:21:22.090Z" itemprop="datePublished">2019-06-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/计算机网络6/">计算机网络（六）：（接）数据链路层</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>数据链路层直白感觉就是加工数据让数据层无脑传送</strong>  </p>
<ol>
<li>流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方式有：停止-等待协议和滑动窗口协议</li>
<li>停止-等待协议原理：发送方一次只能发一个帧，接收方对于接收到的帧必须反馈一个应答信号，发送方收到对上一个帧的应答信号后，才能发送下一个帧，否则发送方将一直等待（后可由重传技术改进）。效率极低</li>
<li>滑动窗口流量控制基本原理：在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为发送窗口；同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口中存放的帧序号为当前情况下可以发送的帧以及已经发送了但尚未收到确认的帧，在接收端只有当数据帧的序号落入接受窗口内才允许将该数据帧守下，若接收到的数据帧落在接收窗口之外，则一律将其丢弃</li>
<li>数据链路层的可靠传输通常使用确认和超时重传两种机制来完成</li>
<li>传统自动重传请求分为三种：停等式、后退N帧（GBN）以及选择性重传（SR）</li>
<li>单帧滑动窗口与停止等待协议：停止等待协议相当于发送窗口和接收窗口均为1的滑动窗口协议<br>GBN协议：发送方可以连续发帧，当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧；或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方必须重传该出错帧及随后的N个帧。也就是说，接收方值允许按顺序接收帧</li>
<li>GBN协议还规定接收端不一定每收到一个正确的数据帧就必须立即发回一个确认帧，而是可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认消息。也就是说ACKn表示对第n号帧的确认，表示接收方已正确收到了第n号帧及其以前的所有帧，下次期望收到第n+1号帧或者是0号帧</li>
<li>接收端在返回ACKn时，将丢弃那些不按序到达的帧（接受窗口的大小为1）</li>
<li>若采用n个比特对帧编号，则GBN发送窗口的尺寸Wt应满足：1&lt;=Wt&lt;=2^n - 1</li>
<li>SR协议：只重传出现差错的数据帧或者是计时器超时的数据帧。加大接收窗口，以便先收下发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺序号的数据帧收到后再一并送交主机</li>
<li>SR协议中，接收方还可以回复否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传<br>若采用n个比特对帧编号，则SR发送窗口的尺寸Wt和接收窗口的尺寸一般为：Wt=Wr=2^（n - 1）<br>信道利用率：发送方从开始发送数据，到收到第一个确认帧为止，称为一个发送周期，记为T。设发送方在这个周期内共发送了L比特的数据，发送方的数据传输率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下，信道的利用率为（L/C）/T</li>
<li>信道吞吐率 = 信道利用率 * 发送方的发送速率</li>
<li>介质访问控制所要完成的主要任务是为使用介质的每个节点隔离来自同一信道上其他节点所传送的信号，以协调活动节点的传输</li>
<li>用于决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制（MAC）子层</li>
<li>常见的介质访问控制方法有：信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制</li>
<li>信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个几点之间通信的互不干扰的子信道，把广播信道转变为点对点信道。</li>
<li>频分多路复用（FDM）：每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”</li>
<li>时分多路复用（TDM）：将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用<br>统计时分多路复用（STDM，也称异步时分多路复用）：采用STDM帧，STDM帧不是固定分配时隙，而是按需动态地分配时隙，当终端有数据要传送时才会分配到时间片</li>
<li>波分多路复用（WDM）：光的频分多路复用<br>码分多路复用（CDM）：靠不同的编码来区分各路原始信号的一种复用方式，既共享空间，也共享时间</li>
<li>随机访问控制协议，常见协议有：ALOHA协议、CSMA协议、CSMA/CD协议和CSMA/CA协议。它们的核心思想是：胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问控制协议又称为争用型协议</li>
<li>纯ALOHA协议：当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果在一段时间内没有收到确认，该站点就认为传输过程中发生了冲突。发送站点需要随机等待一段时间后再发送数据，直至发送成功</li>
<li>时隙ALOHA协议：将时间划分一段段等长的时隙，规定只能在每个时隙开始时才能发送一个帧。碰撞后重传策略与纯ALOHA协议相似</li>
<li>载波侦听多路访问（Carrier Sense Multiple Access，CSMA）协议：每个站点在发送前都先侦听一下公用的信道，发现信道空闲后再发送。有三种不同的CSMA协议</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 Xu
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>